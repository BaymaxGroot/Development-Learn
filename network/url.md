# URL 解析流程

    现代浏览器是多进程架构

## 地址栏输入信息处理

    当用户在地址栏中输入内容之后，浏览器会判断输入信息是检索信息还是URL

        1. 检索信息 - 构建请求搜索的URL,调用浏览器默认的搜索引擎进行检索
        2. URL - 浏览器主进程会通过IPC将URL发送给网络进程

## 网络进程

    会查找浏览器缓存，判断是否存在，是否过期

        1. 存在且不过期，直接返回缓存信息

        2. 如果没有缓存，就进行DNS解析
    
### 1. 缓存策略

1. 强缓存

    Expires
        
        http1.0中使用的字段，返回的是一个绝对时间表示的过期时间；这就导致了如果服务器和浏览器时间不一致的情况下，缓存可能会失效

    Cache-Control(优先级高)

        http1.1中使用的字段，可以定义以下属性值

            max-age - 单位为s，表示缓存有效的相对时间
            no-store - 禁止使用缓存
            no-cache - 需要进行协商缓存
            public - 可被所有终端用户或CDN缓存
            private - 只可被终端用户缓存

2. 协商缓存 

    Last-Modified & If-Modified-Since

        资源最新修改时间，精确度到s

    Etag & If-None-Match(优先级高)

        资源唯一标识，通常为资源内容的hash

## DNS域名解析

    目的是为了得到真实的IP地址

    1. 递归查询

        浏览器自身的DNS缓存 - 本机hosts文件 - 本地DNS服务器

    2. 迭代查询

        本地DNS服务器与根域及其子域之间的查询方式

## 建立http连接或https连接

    TCP三次握手

        1. 客户端发送SYN报文给服务器，并将自己的状态设置为SYN_SEND
        2. 服务器收到后，返回SYN和ACK报文给客户端，并将自己的状态设置为SYN_RCVD
        3. 客户端收到后，返回ACK报文给服务器，随后双方状态进入ESTABLISHED

    目的确保客户端和服务器双方的收发能力，3次是为了避免历史连接

    SSL四次握手(若为https)

        首先要申请CA证书，并安装在服务器

        1. 客户端将自己支持的加密规则发送给服务器 - 其中包括了协议版本、会话id、密码构件、压缩方法、等
        2. 服务器从接收到客户端的请求后，从发过来的加密规则中选一个自身也支持的加密方法和hash算法，并向浏览器发送带有公钥的证书
        3. 浏览器解析证书，并校验证书的合法性
            若合法或用户接受了不合法的证书，浏览器会生成一串随机数的密钥，并用证书中的公钥进行加密，使用约定的hash计算握手信息，并将以上信息发送给服务器
        4. 服务器收到后会使用自己的私钥将信息解密并取出密钥，使用密钥对发送过来的握手信息进行加密，并验证hash是否与客户端发过来的一致，若一致则使用密钥加密一段握手信息发送给客户端
        5. 客户端解密并计算握手信息的hash，如果与服务器发来的一致，则握手过程结束。之后所有的通信数据都采用对称加密算法进行加解密

    数字签名

        1. 制作 - 将证书的明文信息用hash函数加密得到信息摘要，然后CA用私钥进行加密，得到数字签名，明文和数字签名组成证书
        2. 验证 - 用CA机构的公钥对数字签名解密得到信息摘要，用证书里面的hash算法对证书明文进行hash得到信息摘要，比较两次的信息摘要是否相同

## 发送http请求

    构建http请求头

    请求从应用层出发，经过传输层、网络层、数据链路层、物理层找到服务器；

    Get、POST请求比较

        1. 在浏览器回退时，GET请求不会再次提交、POST请求会再次提交
        2. GET请求会被浏览器主动缓存、请求参数会被完整的保留在浏览器历史记录里
        3. GET请求在URL中传递的参数是有长度限制的
        4. GET请求一般将请求参数放置在URL中、POST则是在body中

## 服务器返回对应资源

    这里的服务器可以是Server或者是CDN

    网络进程分析响应头信息，如:

        1. 存在 Location字段，再次发起请求，表明重定向

        2. Content-Type判断文件类型，如果不是html类型，则调用不同的进程处理，若是html类型，继续处理

    网络进程拿到返回的资源信息，会发送消息到浏览器主进程；浏览器主进程发送消息，提醒渲染进程准备接受资源信息

    渲染进程和网络进程进行通信，接收资源信息，并和浏览器主进程进行通信，浏览器主进程开始刷新页面，url等安全信息

## 浏览器解析渲染

    渲染进程绘制出页面之前，页面将存在空白时间

### 1. 多个Tab页共用渲染进程

    浏览器对于在当前站点打开的新的tab页面会做一些优化，如果他们同源，且执行环境相同，会直接复用当前站点的渲染进程，这样可以提高渲染的性能，也能让父窗口和子窗口建立关联，但这样也会造成以下隐患

        1. 共用一个进程，如果当前进程中的一个线程出现问题，当前进程就会崩溃，共用一个进程的页面也会崩溃
        2. 如果新打开的页面有恶意脚本攻击，那么在新打开的页面就可以通过window.opener获取父窗口的操作权限

    可以使用以下方法来保证不同页面使用不同的进程

        1. a标签 - 添加 rel="noopener norefferer"
        2. window.open - 设置新窗口的opener为null

## 断开连接

    四次挥手

        1. 客户端发送FIN，用来关闭客户端到服务器的连接; FIN+ACK报文，并置发送序号为X，即SEQ=X，然后客户端进入FIN-WAIT-1状态，表明没有数据要发送
        2. 服务器收到FIN包后，发送一个确认序号ACK，并携带上自己的发送序号SEQ,即ACK=X+1，SEQ=Z，然后服务器进入CLOSE-WAIT状态
            客户端收到后进入FIN-WAIT-2状态
        4. 服务器发送FIN，用来关闭服务器到客户端的连接；FIN+ACK报文，并置发送信号为X，即SEQ=X，然后服务器进入LAST-ACK状态
        5. 客户端收到后，发送ACK+SEQ报文，然后客户端进入TIME-WAIT状态，然后客户端等待一段时间后进入CLOSED状态
            服务器收到后立马进入CLOSED状态